# This is a basic workflow to help you get started with Actions

name: Publish

# Controls when the action will run.
on:
  # Triggers the workflow on push or pull request events but only for the refactor branch
  push:
    branches: [ refactor ]
  pull_request:
    branches: [ refactor ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  pack:
    # The type of runner that the job will run on
    runs-on: windows-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      - name: Copy mission files to templates
        run: |
          $mainFolder = "$($Env:GITHUB_WORKSPACE)"
          $templateFolder = "$($Env:GITHUB_WORKSPACE)\Mission-Templates"
          $unwantedFoldersAndFiles = @("mission.sqm", ".vscode", ".github", ".git", ".gitignore", "Mission-Templates", "Pbo-Tools")
          $mainFiles = Get-ChildItem -Path "$mainFolder" | Where-Object { $_.Name -notin $unwantedFoldersAndFiles }
          $missionFolders = Get-ChildItem -Path "$templateFolder" -Directory
          if ($missionFolders.Count -gt 0)
          {
              ForEach ($folder in $missionFolders)
              {
                  Write-Output "-----------------------------------------------------"
                  Write-Output "Mission Folder: $folder"
                  Write-Output "-----------------------------------------------------"
                  ForEach ($file in $mainFiles)
                  {
                      Try
                      {
                          Copy-Item -Path "$($file.Fullname)" -Destination "$folder\$($file.Name)" -Recurse -Force
                          Write-Output "    $($file.Name) --> $folder\$($file.Name)"
                      }
                      Catch
                      {
                          $ErrorMessage = $_ | Out-String
                          Write-Output "The following error occured while copying files for $($file.Name) from Main Mission to Template Mission:"
                          Write-Output $ErrorMessage
                      }
                  }
                  Write-Output "-----------------------------------------------------"
              }
          }
        shell: pwsh

      - name: Install Mikero Tools
        run: |
          $PboTools = "$($Env:GITHUB_WORKSPACE)\Pbo-Tools\"
          Get-ChildItem "$PboTools" | ForEach-Object {
            echo "Installing $_"
            Start-Process -Wait $_.FullName "/S"
          }
          echo "Updating environment variables"
          echo "C:\Program Files (x86)\Mikero\DePboTools\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        shell: pwsh

      - name: Pack mission files to PBOs
        run: |
          Get-Command makepbo
          $templateFolder = "$($Env:GITHUB_WORKSPACE)\Mission-Templates"
          $missionFolders = Get-ChildItem -Path "$templateFolder" -Directory
          New-Item -Path "$($Env:GITHUB_WORKSPACE)\Publish\" -ItemType Directory
          if ($missionFolders.Count -gt 0)
          {
              ForEach ($folder in $missionFolders)
              {
                  Try
                  {
                    makepbo -P -B -A -X="none" "$folder"
                    Copy-Item -Path "$folder.pbo" -Destination "$($Env:GITHUB_WORKSPACE)\Publish\$($folder.Name).pbo"
                  }
                  Catch
                  {
                      $ErrorMessage = $_ | Out-String
                      Write-Output "The following error occured while packing $($folder.Name):"
                      Write-Output $ErrorMessage
                  }
              }
          }
        shell: pwsh

      - uses: actions/upload-artifact@v2
        with:
          name: TRGM2-Missions
          path: ${{ github.workspace }}/Publish/**/*
          if-no-files-found: error
  lint:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      - name: Remove non-mission files
        run: |
          function Remove-FileSystemItem {
            param(
              [Parameter(ParameterSetName = 'Path', Mandatory, Position = 0, ValueFromPipeline, ValueFromPipelineByPropertyName)]
              [string[]] $Path
              ,
              [Parameter(ParameterSetName = 'Literalpath', ValueFromPipelineByPropertyName)]
              [Alias('PSPath')]
              [string[]] $LiteralPath
              ,
              [switch] $Recurse
            )
            begin {
              # !! Workaround for https://github.com/PowerShell/PowerShell/issues/1759
              if ($ErrorActionPreference -eq [System.Management.Automation.ActionPreference]::Ignore) { $ErrorActionPreference = 'Ignore' }
              $targetPath = ''
              $yesToAll = $noToAll = $false
              function trimTrailingPathSep([string] $itemPath) {
                if ($itemPath[-1] -in '\', '/') {
                  # Trim the trailing separator, unless the path is a root path such as '/' or 'c:\'
                  if ($itemPath.Length -gt 1 -and $itemPath -notmatch '^[^:\\/]+:.$') {
                    $itemPath = $itemPath.Substring(0, $itemPath.Length - 1)
                  }
                }
                $itemPath
              }
              function getTempPathOnSameVolume([string] $itemPath, [string] $tempDir) {
                if (-not $tempDir) { $tempDir = [IO.Path]::GetDirectoryName($itemPath) }
                [IO.Path]::Combine($tempDir, [IO.Path]::GetRandomFileName())
              }
              function syncRemoveFile([string] $filePath, [string] $tempDir) {
                # Clear the ReadOnly attribute, if present.
                if (($attribs = [IO.File]::GetAttributes($filePath)) -band [System.IO.FileAttributes]::ReadOnly) {
                  [IO.File]::SetAttributes($filePath, $attribs -band -bnot [System.IO.FileAttributes]::ReadOnly)
                }
                $tempPath = getTempPathOnSameVolume $filePath $tempDir
                [IO.File]::Move($filePath, $tempPath)
                [IO.File]::Delete($tempPath)
              }
              function syncRemoveDir([string] $dirPath, [switch] $recursing) {
                if (-not $recursing) { $dirPathParent = [IO.Path]::GetDirectoryName($dirPath) }
                # Clear the ReadOnly attribute, if present.
                # Note: [IO.File]::*Attributes() is also used for *directories*; [IO.Directory] doesn't have attribute-related methods.
                if (($attribs = [IO.File]::GetAttributes($dirPath)) -band [System.IO.FileAttributes]::ReadOnly) {
                  [IO.File]::SetAttributes($dirPath, $attribs -band -bnot [System.IO.FileAttributes]::ReadOnly)
                }
                # Remove all children synchronously.
                $isFirstChild = $true
                foreach ($item in [IO.directory]::EnumerateFileSystemEntries($dirPath)) {
                  if (-not $recursing -and -not $Recurse -and $isFirstChild) {
                    # If -Recurse wasn't specified, prompt for nonempty dirs.
                    $isFirstChild = $false
                    # Note: If -Confirm was also passed, this prompt is displayed *in addition*, after the standard $PSCmdlet.ShouldProcess() prompt.
                    #       While Remove-Item also prompts twice in this scenario, it shows the has-children prompt *first*.
                    if (-not $PSCmdlet.ShouldContinue("The item at '$dirPath' has children and the -Recurse switch was not specified. If you continue, all children will be removed with the item. Are you sure you want to continue?", 'Confirm', ([ref] $yesToAll), ([ref] $noToAll))) { return }
                  }
                  $itemPath = [IO.Path]::Combine($dirPath, $item)
                  ([ref] $targetPath).Value = $itemPath
                  if ([IO.Directory]::Exists($itemPath)) {
                    syncremoveDir $itemPath -recursing
                  }
                  else {
                    syncremoveFile $itemPath $dirPathParent
                  }
                }
                # Finally, remove the directory itself synchronously.
                ([ref] $targetPath).Value = $dirPath
                $tempPath = getTempPathOnSameVolume $dirPath $dirPathParent
                [IO.Directory]::Move($dirPath, $tempPath)
                [IO.Directory]::Delete($tempPath)
              }
            }
            process {
              $isLiteral = $PSCmdlet.ParameterSetName -eq 'LiteralPath'
              if ($env:OS -ne 'Windows_NT') {
                # Unix: simply pass through to Remove-Item, which on Unix works reliably and synchronously
                Remove-Item @PSBoundParameters
              }
              else {
                # Windows: use synchronous custom implementation
                foreach ($rawPath in ($Path, $LiteralPath)[$isLiteral]) {
                  # Resolve the paths to full, filesystem-native paths.
                  try {
                    # !! Convert-Path does find hidden items via *literal* paths, but not via *wildcards* - and it has no -Force switch (yet)
                    # !! See https://github.com/PowerShell/PowerShell/issues/6501
                    $resolvedPaths = if ($isLiteral) { Convert-Path -ErrorAction Stop -LiteralPath $rawPath } else { Convert-Path -ErrorAction Stop -path $rawPath }
                  }
                  catch {
                    Write-Error $_ # relay error, but in the name of this function
                    continue
                  }
                  try {
                    $isDir = $false
                    foreach ($resolvedPath in $resolvedPaths) {
                      # -WhatIf and -Confirm support.
                      if (-not $PSCmdlet.ShouldProcess($resolvedPath)) { continue }
                      if ($isDir = [IO.Directory]::Exists($resolvedPath)) {
                        # dir.
                        # !! A trailing '\' or '/' causes directory removal to fail ("in use"), so we trim it first.
                        syncRemoveDir (trimTrailingPathSep $resolvedPath)
                      }
                      elseif ([IO.File]::Exists($resolvedPath)) {
                        # file
                        syncRemoveFile $resolvedPath
                      }
                      else {
                        Throw "Not a file-system path or no longer extant: $resolvedPath"
                      }
                    }
                  }
                  catch {
                    if ($isDir) {
                      $exc = $_.Exception
                      if ($exc.InnerException) { $exc = $exc.InnerException }
                      if ($targetPath -eq $resolvedPath) {
                        Write-Error "Removal of directory '$resolvedPath' failed: $exc"
                      }
                      else {
                        Write-Error "Removal of directory '$resolvedPath' failed, because its content could not be (fully) removed: $targetPath`: $exc"
                      }
                    }
                    else {
                      Write-Error $_  # relay error, but in the name of this function
                    }
                    continue
                  }
                }
              }
            }
          }
          Remove-FileSystemItem "$($Env:GITHUB_WORKSPACE)\Mission-Templates" -Recurse
          Remove-FileSystemItem "$($Env:GITHUB_WORKSPACE)\Pbo-Tools" -Recurse
          Remove-FileSystemItem "$($Env:GITHUB_WORKSPACE)\.git" -Recurse
          Remove-FileSystemItem "$($Env:GITHUB_WORKSPACE)\.github" -Recurse
          Remove-Item -Path "$($Env:GITHUB_WORKSPACE)\.gitignore"

      - name: Validate with SQFLint
        uses: arma-actions/sqflint@v1.0
